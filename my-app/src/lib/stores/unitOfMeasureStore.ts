import { writable, get } from 'svelte/store';
import { db, type UnitOfMeasureDbo } from '../services/dbService';
import { syncService } from '../services/syncService';
import { offlineStore } from './offlineStore';
import type { ApiError } from '../services/apiService'; // For error type consistency
import { liveQuery } from 'dexie'; // For reactive updates from Dexie

export interface UnitOfMeasureState {
  units: UnitOfMeasureDbo[];
  isLoading: boolean;
  error: ApiError | Error | null; // Broader error type
}

const initialUnitOfMeasureState: UnitOfMeasureState = {
  units: [],
  isLoading: true, // Set to true initially, liveQuery will update it
  error: null,
};

function createUnitOfMeasureStore() {
  const { subscribe, update, set } = writable<UnitOfMeasureState>(initialUnitOfMeasureState);

  // Use Dexie's liveQuery for reactive updates to the units list
  const unitsLiveQuery = liveQuery(() => db.unitsOfMeasure.orderBy('codigo').toArray());

  const unsubscribeFromLiveQuery = unitsLiveQuery.subscribe({
    next: (data) => {
      update(state => ({ ...state, units: data, isLoading: false, error: null }));
    },
    error: (err) => {
      console.error("LiveQuery error in unitOfMeasureStore:", err);
      // Ensure err is an Error instance
      const errorToShow = err instanceof Error ? err : new Error(String(err));
      update(state => ({ ...state, error: errorToShow, isLoading: false, units: [] })); // Clear units on error
      // Consider if you want to return a fallback value or re-throw. Dexie's liveQuery expects void or Promise<void>.
    }
  });
  
  // Manual fetchAll, e.g., for an explicit refresh button, though liveQuery handles reactivity.
  const fetchAll = async () => {
    update(state => ({ ...state, isLoading: true, error: null }));
    try {
      // This method is less critical due to liveQuery, but can be used for explicit user-triggered refresh.
      // It could potentially trigger a server sync check here or rely on syncService's own triggers.
      // For now, it just ensures the isLoading flag is managed if called.
      // const currentUnits = await db.unitsOfMeasure.orderBy('codigo').toArray();
      // update(state => ({ ...state, units: currentUnits, isLoading: false }));
      // liveQuery should handle this, so log and set loading to false.
      console.log("fetchAll called. LiveQuery is the primary source of data. Current state is driven by Dexie updates.");
      update(state => ({...state, isLoading: false}));
    } catch (err) {
      console.error('Error explicitly fetching units from Dexie for refresh:', err);
      const errorToShow = err instanceof Error ? err : new Error(String(err));
      update(state => ({ ...state, isLoading: false, error: errorToShow }));
    }
  };

  const add = async (unitData: Omit<UnitOfMeasureDbo, 'localId' | 'id' | 'sincronizado' | 'fechaModificacion'>) => {
    if (!unitData.codigo || !unitData.codigo.trim()) {
      const error = new Error("Unit 'codigo' (business key) is required and cannot be empty.");
      console.error(error.message);
      update(state => ({ ...state, error }));
      // Optionally use toastStore here directly if appropriate
      // import { toastStore } from './toastStore'; // if you decide to use it here
      // toastStore.addToast(error.message, 'error');
      return;
    }
    try {
      update(state => ({ ...state, error: null })); // Clear previous error
      const newUnit: Omit<UnitOfMeasureDbo, 'localId'> = { // localId is auto-generated by Dexie
        ...unitData,
        id: null, // Server will assign this after sync
        sincronizado: false,
        fechaModificacion: new Date(),
      };
      // Add to Dexie. liveQuery will automatically update the store's 'units' list.
      const localId = await db.unitsOfMeasure.add(newUnit as UnitOfMeasureDbo); 
      console.log(`Unit added to Dexie with localId: ${localId}`);

      // Queue for backend sync
      // Payload for 'create' should be what API expects (e.g., no localId, no sync status)
      const apiPayload = { name: newUnit.name, symbol: newUnit.symbol, codigo: newUnit.codigo };
      await syncService.addToQueue('unitsOfMeasure', 'create', apiPayload, newUnit.codigo);
    } catch (err) {
      console.error('Error adding unit to Dexie or queueing:', err);
      const errorToShow = err instanceof Error ? err : new Error(String(err));
      update(state => ({ ...state, error: errorToShow }));
    }
  };

  // localId is Dexie's auto-incrementing PK.
  // currentCodigo is the business key of the item being updated (used for syncService).
  const updateUnit = async (
    localId: number, 
    unitChanges: Partial<Omit<UnitOfMeasureDbo, 'localId' | 'id' | 'sincronizado' | 'fechaModificacion' | 'codigo'>>, 
    currentCodigo: string
  ) => {
    try {
      update(state => ({ ...state, error: null }));
      await db.unitsOfMeasure.update(localId, {
        ...unitChanges, // Apply the provided changes
        sincronizado: false, // Mark as needing sync
        fechaModificacion: new Date(),
      });
      // liveQuery will automatically update the store's 'units' list.
      console.log(`Unit with localId ${localId} updated in Dexie.`);

      // Payload for 'update' should be only the changes the API expects.
      const apiPayload = { ...unitChanges };
      await syncService.addToQueue('unitsOfMeasure', 'update', apiPayload, currentCodigo);
    } catch (err) {
      console.error(`Error updating unit with localId ${localId} in Dexie or queueing:`, err);
      const errorToShow = err instanceof Error ? err : new Error(String(err));
      update(state => ({ ...state, error: errorToShow }));
    }
  };

  // localId is Dexie's auto-incrementing PK.
  // codigo is the business key (used for syncService).
  const remove = async (localId: number, codigo: string) => {
    try {
      update(state => ({ ...state, error: null }));
      await db.unitsOfMeasure.delete(localId);
      // liveQuery will automatically update the store's 'units' list.
      console.log(`Unit with localId ${localId} deleted from Dexie.`);

      // Payload for 'delete' might be empty or just the key, depending on API.
      // syncService uses entityKey for DELETE path, so payload can be minimal or just the key.
      await syncService.addToQueue('unitsOfMeasure', 'delete', { codigo }, codigo);
    } catch (err) {
      console.error(`Error deleting unit with localId ${localId} from Dexie or queueing:`, err);
      const errorToShow = err instanceof Error ? err : new Error(String(err));
      update(state => ({ ...state, error: errorToShow }));
    }
  };
  
  // Cleanup liveQuery subscription. Svelte components can call this in their onDestroy lifecycle.
  const destroy = () => {
    if (unsubscribeFromLiveQuery && typeof unsubscribeFromLiveQuery === 'function') {
      unsubscribeFromLiveQuery();
      console.log("Unsubscribed from unitOfMeasureStore liveQuery.");
    }
  };

  // Initial isLoading state is true. liveQuery's first emission (next or error) will set it to false.
  // No explicit fetchAll() call needed here for initial load due to liveQuery.

  return {
    subscribe,
    fetchAll, // Keep for explicit refresh scenarios if any
    add,
    update: updateUnit,
    remove,
    destroy, // Expose destroy for component cleanup
  };
}

export const unitOfMeasureStore = createUnitOfMeasureStore();

// Regarding the offlineStore.subscribe block:
// The previous comment is important: "Since `unitOfMeasureStore` is now reactive
// to Dexie changes via liveQuery, calling `fetchAll()` might be redundant if `syncService`
// correctly updates Dexie, as liveQuery will pick up those changes."
// If syncService.processQueue() updates records in Dexie (e.g. sets sincronizado=true, updates server 'id'),
// liveQuery on unitsOfMeasure table will automatically reflect these changes in this store.
// So, the `fetchAll()` call in offlineStore's subscription (if it was there for this store)
// is likely no longer needed for data reactivity.
// The syncService itself might show toasts for its progress.
// This store should primarily reflect the local Dexie state.
// The current `offlineStore` in the prompt doesn't show a `fetchAll` for this store, which is good.
// It only calls `syncService.processQueue()`.
```
